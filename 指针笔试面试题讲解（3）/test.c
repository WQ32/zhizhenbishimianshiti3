#include <stdio.h>

//// 笔试题3
//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	//小端存储
//	//01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00
//	int* ptr1 = (int*)(&a + 1);
//	//ptr1相当于整个数组结尾处的地址，&a指整个数组的地址，&a+1跳过整个数组，强制转换成整形指针，赋给ptr1
//	int* ptr2 = (int*)((int)a + 1);
//	//a是首元素地址，(int)a将a这个首元素地址转换成整数，比如0x00000005 ->5
//	//(int)a+1就相当于5+1=6，即地址变成了0x00000006
//	//在内存中最小的内存单位是一个字节，每个字节都给一个地址，所以两个相邻的地址间差一个字节
//	printf("%x,%x", ptr1[-1], *ptr2);
//	//0x4,
//	//ptr1[-1] == *(ptr1+(-1))=*(ptr1-1) 即04 00 00 00
//	//ptr2整形指针，解引用访问4个字节,跳过01，结果就是00 00 00 02
//	//又由于是小端存储，所以结果是0x00 00 00 04，和0x02 00 00 00(0x02中的0可省略)
//	//即结果 4，2000000
//	return 0;
//}

////笔试题4
//int main()
//{
//	int a[3][2] = { (0,1),(2,3),(4,5) };  //逗号表达式，结果1 3 5
//	//内存中存放的是
//	// 1  3
//	// 5  0
//	// 0  0
//	int* p;
//	p = a[0];
//	//a[0]是第一行的数组名，表示首元素地址，第一行第一个元素的地址
//	printf("%d\n", p[0]);
//	// p[0]=*(p+0)
//	//结果 1
//	return 0;
//}

//笔试题5
int main()
{
	int a[5][5];
	int(*p)[4];
	//p有4个元素，每个元素都是int型，每个元素占4个字节
	p = a;
	// p: int(*)[4]; a: int(*)[5]
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	// a[4][2]就是第5行第3个元素
	// p[4][2] = *(*(p+4)+2)
	//这里p指向首元素地址，p+1相当于跳过4个字节，p+4跳过16个字节，指向第4行第2个元素起始处,
	// *(p+4)又是指第4行第2个元素，所以在它的地址上加2，就是指第4行第4个元素起始处
	//所以&p[4][2]与&a[4][2]差4个字节，即-4
	//10000000 00000000 00000000 00000100
	//11111111 11111111 11111111 11111011
	//11111111 11111111 11111111 11111100
	//%p输出地址,1111 = 16 = F,1100 = 12 = C,即FFFFFFFC
	//%d输出十进制数（原码）,即 10000000 00000000 00000000 00000100 = -4
	return 0;
}